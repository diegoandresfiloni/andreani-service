/**
 * Microservicio Node.js para Andreani PyM√©s
 * Maneja login OAuth2 + WebSocket SignalR
 * OPTIMIZADO PARA RAILWAY
 */

const express = require('express');
const { HubConnectionBuilder, HttpTransportType } = require('@microsoft/signalr');
const puppeteer = require('puppeteer-core');
const chromium = require('@sparticuz/chromium');
const cors = require('cors');
require('dotenv').config();

const app = express();
app.use(express.json());
app.use(cors());

const PORT = process.env.PORT || 3000;

// Cache de tokens
let tokenCache = {
    access_token: null,
    expires_at: null
};

/**
 * Login con Puppeteer (navegador headless)
 */
async function loginAndreani(username, password) {
    console.log('üîê Iniciando login con Puppeteer...');
    
    let browser = null;
    
    try {
        // Configurar Chromium para Railway
        const executablePath = await chromium.executablePath();
        
        console.log('üìç Chromium path:', executablePath);
        
        // Lanzar browser
        browser = await puppeteer.launch({
            args: chromium.args,
            defaultViewport: chromium.defaultViewport,
            executablePath: executablePath,
            headless: chromium.headless,
        });
        
        console.log('‚úÖ Browser iniciado correctamente');
        
        const page = await browser.newPage();
        
        // Interceptar requests para capturar el token
        let accessToken = null;
        
        page.on('request', request => {
            const url = request.url();
            if (url.includes('access_token=')) {
                const match = url.match(/access_token=([^&]+)/);
                if (match) {
                    accessToken = match[1];
                    console.log('üéØ Token capturado en request');
                }
            }
        });
        
        page.on('response', async response => {
            const url = response.url();
            if (url.includes('token') || url.includes('authorize')) {
                try {
                    const headers = response.headers();
                    if (headers['authorization']) {
                        const authHeader = headers['authorization'];
                        if (authHeader.startsWith('Bearer ')) {
                            accessToken = authHeader.substring(7);
                            console.log('üéØ Token capturado en response header');
                        }
                    }
                } catch (e) {
                    // Ignorar errores
                }
            }
        });
        
        // Ir a la p√°gina de login
        console.log('üìÑ Navegando a p√°gina de login...');
        await page.goto('https://onboarding.andreani.com/', {
            waitUntil: 'networkidle2',
            timeout: 60000
        });
        
        console.log('‚úÖ P√°gina cargada, buscando formulario de login...');
        
        // Esperar y completar formulario
        await page.waitForSelector('input[type="email"], input[name="signInName"]', { timeout: 30000 });
        await page.type('input[type="email"], input[name="signInName"]', username, { delay: 100 });
        
        await page.waitForSelector('input[type="password"], input[name="password"]', { timeout: 10000 });
        await page.type('input[type="password"], input[name="password"]', password, { delay: 100 });
        
        console.log('‚úèÔ∏è Credenciales ingresadas, haciendo clic en login...');
        
        // Click en bot√≥n de login
        await page.click('button[type="submit"], button#next');
        
        // Esperar redirecci√≥n
        await page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 30000 });
        
        console.log('‚úÖ Login exitoso, esperando token...');
        
        // Esperar un poco m√°s para asegurar que el token se capture
        await page.waitForTimeout(3000);
        
        // Si no capturamos el token en las requests, intentar obtenerlo del localStorage
        if (!accessToken) {
            console.log('üîç Buscando token en localStorage...');
            accessToken = await page.evaluate(() => {
                // Buscar en localStorage
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    const value = localStorage.getItem(key);
                    if (value && value.includes('eyJ')) {
                        try {
                            const parsed = JSON.parse(value);
                            if (parsed.access_token || parsed.accessToken) {
                                return parsed.access_token || parsed.accessToken;
                            }
                        } catch (e) {
                            if (value.startsWith('eyJ')) {
                                return value;
                            }
                        }
                    }
                }
                
                // Buscar en cookies
                const cookies = document.cookie.split(';');
                for (let cookie of cookies) {
                    const [name, value] = cookie.trim().split('=');
                    if (value && value.startsWith('eyJ')) {
                        return value;
                    }
                }
                
                return null;
            });
        }
        
        await browser.close();
        browser = null;
        
        if (!accessToken) {
            throw new Error('No se pudo obtener el access token');
        }
        
        console.log('üéâ Token obtenido exitosamente');
        
        // Guardar en cache (v√°lido por 1.5 horas)
        tokenCache.access_token = accessToken;
        tokenCache.expires_at = Date.now() + (90 * 60 * 1000); // 90 minutos
        
        return accessToken;
        
    } catch (error) {
        console.error('‚ùå Error en loginAndreani:', error.message);
        if (browser) {
            await browser.close();
        }
        throw error;
    }
}

/**
 * Obtiene token (desde cache o haciendo login)
 */
async function getAccessToken(username, password) {
    // Si hay token v√°lido en cache, usarlo
    if (tokenCache.access_token && tokenCache.expires_at > Date.now()) {
        console.log('‚úÖ Usando token desde cache');
        return tokenCache.access_token;
    }
    
    // Token expirado o no existe, hacer login
    console.log('üîÑ Token expirado, renovando...');
    return await loginAndreani(username, password);
}

/**
 * Cotiza env√≠o usando SignalR
 */
async function cotizarEnvio(accessToken, params) {
    const hubUrl = `https://pymes-api.andreani.com/hubCotizacion?access_token=${accessToken}`;
    
    const connection = new HubConnectionBuilder()
        .withUrl(hubUrl, {
            skipNegotiation: true,
            transport: HttpTransportType.WebSockets
        })
        .build();
    
    try {
        await connection.start();
        console.log('üîå Conectado al WebSocket');
        console.log('üì¶ Par√°metros recibidos:', JSON.stringify(params, null, 2));
        
        // Preparar objeto de cotizaci√≥n con todos los datos
        const cotizacionData = {
            usuarioId: params.usuarioId || '',
            tipoDeEnvioId: params.tipoDeEnvioId,
            sucursalOrigen: params.sucursalOrigen,
            codigoPostalDestino: params.codigoPostalDestino,
            bultos: params.bultos
        };
        
        // Agregar datos del destinatario si est√°n presentes
        if (params.destinatario) {
            cotizacionData.destinatario = params.destinatario;
            console.log('üë§ Datos del destinatario incluidos:', params.destinatario);
        }
        
        console.log('üì§ Enviando a Andreani:', JSON.stringify(cotizacionData, null, 2));
        
        // Invocar m√©todo de cotizaci√≥n
        const result = await connection.invoke('Cotizar', cotizacionData);
        
        console.log('üì• Respuesta de Andreani:', JSON.stringify(result, null, 2));
        
        await connection.stop();
        
        return result;
        
    } catch (error) {
        console.error('‚ùå Error en WebSocket:', error);
        await connection.stop();
        throw error;
    }
}

// ============================================
// ENDPOINTS
// ============================================

/**
 * POST /login
 * Hace login y retorna el access token
 */
app.post('/login', async (req, res) => {
    try {
        const { username, password } = req.body;
        
        if (!username || !password) {
            return res.status(400).json({ error: 'Username y password requeridos' });
        }
        
        const token = await getAccessToken(username, password);
        
        res.json({
            success: true,
            access_token: token,
            expires_in: 7200
        });
        
    } catch (error) {
        console.error('‚ùå Error en login:', error.message);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

/**
 * POST /cotizar
 * Cotiza un env√≠o
 */
app.post('/cotizar', async (req, res) => {
    try {
        const { username, password, params } = req.body;
        
        console.log('üîç Request recibido en /cotizar');
        console.log('Username:', username);
        console.log('Params:', JSON.stringify(params, null, 2));
        
        if (!username || !password) {
            return res.status(400).json({ 
                success: false,
                error: 'Credenciales requeridas' 
            });
        }
        
        if (!params) {
            return res.status(400).json({ 
                success: false,
                error: 'Par√°metros de cotizaci√≥n requeridos' 
            });
        }
        
        // Obtener token
        const token = await getAccessToken(username, password);
        
        // Cotizar
        const result = await cotizarEnvio(token, params);
        
        res.json({
            success: true,
            data: result
        });
        
    } catch (error) {
        console.error('‚ùå Error en cotizaci√≥n:', error.message);
        console.error('Stack:', error.stack);
        res.status(500).json({
            success: false,
            error: error.message,
            details: error.stack
        });
    }
});

/**
 * GET /health
 * Verifica que el servicio est√© funcionando
 */
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        uptime: process.uptime(),
        token_cached: !!tokenCache.access_token,
        token_expires_in: tokenCache.expires_at ? Math.floor((tokenCache.expires_at - Date.now()) / 1000) : 0
    });
});

/**
 * POST /refresh-token
 * Fuerza renovaci√≥n del token
 */
app.post('/refresh-token', async (req, res) => {
    try {
        const { username, password } = req.body;
        
        // Limpiar cache
        tokenCache.access_token = null;
        tokenCache.expires_at = null;
        
        const token = await getAccessToken(username, password);
        
        res.json({
            success: true,
            access_token: token
        });
        
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Ruta ra√≠z
app.get('/', (req, res) => {
    res.json({
        service: 'Andreani Service API',
        version: '1.0.0',
        endpoints: {
            health: 'GET /health',
            login: 'POST /login',
            cotizar: 'POST /cotizar',
            refresh: 'POST /refresh-token'
        },
        status: 'running',
        chrome_path: process.env.CHROME_PATH || 'chrome-aws-lambda'
    });
});

// Iniciar servidor
app.listen(PORT, () => {
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë   üöÄ Andreani Service RUNNING         ‚ïë
‚ïë   üì° Port: ${PORT}                       ‚ïë
‚ïë   üîó Ready to receive requests        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    `);
});